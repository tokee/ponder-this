2022-05-29

Basic idea implemented (non-optimized): Keep track of the free edges on board
and of all free edges for pieces. If an edge (can be 1, 2, 3, 4 or 2-opposing edges)
becomes negative, the puzzle is in an insolvable state and a backtrack must
be performed.

This works, but it is hard to judge how feasible it is to find a solution.
It is slow going (190 free after an hour or so) with nearly just the edges
permutating, but on the other hand it is better to skip a path early in the path.

TODO/Ideas:

1) Speed is ~1000 pieces/second.
Optimizing to 100x that should be possible without too much trouble.

Currently the bottleneck is finding the pieces that are valid for a given field.
Outer edges are resolved for the field and pieces are requested from maps.
Switching to a more efficient format, such as a bit-packed representation, should
make it possible to hold the outer edges and a marker for which outer edges are
defined.

There are 23 edge colors plus "not set". This packs to 5 bits. With 4 edges this
is 20 bits. Performing fast resolving by packing which edges are defined by a bit
per edge, this adds 4 bits: <4><5><5><5><5> = 24 bits total.

Keeping with the theme, there are 256 pieces + 1 "no piece" (9 bits) with 4
rotations (2 bits). Replicating the outer edges structure without the 4
define-bits (pieces always have 4 colors) adds another 20 bits, for a grand total
of 24+20+9+2 = 55 bits.

Adding or removing pieces to the field should also update the state long
described above. This should be fast enough:
1) Update full state for the origo field
2) Update surrounding colors for the 8 fields around the origo field

Getting valid pieces for a given field would be reduced to

state = board[x][y]
edges = (state >>> <Outer-Edges-Define-Bit-shift>) & OEDB_mask
switch (edges) {
  case 0b0000: return tracker.getFree()
  case 0b1000: return tracker.getOne(getHash(edges, state))
  case 0b0100: return tracker.getOne(getHash(edges, state))
  ...
  case 0b1100: return tracker.getTwo(getHash(edges, state))
  ...
  case 0b1010: return tracker.getOpposing(getHash(edges, state))
  ...
  case 0b1111: return tracker.getFour(getHash(edges, state))
}
int getHash(int edges, long state) {
switch (edges) {
  case 0b0000: return 0L // Never used
  case 0b1000: return <shift-mask-outer-north-color>
  case 0b0100: return <shift-mask-outer-east-color>
  ...
  case 0b1100: return <shift-mask-outer-north-and-east-color>
  ...
  case 0b1010: return <shift-mask-concatenate-outer-north-and-south-color>
  ...
  case 0b1111: return <hash-for-four>
}
add(int piece, int rotation, x, y) {
  ...
  // set inner state from piece, rotation
  
  // Update edge tracker
  tracker.decOne(getHash(0b1000, state))
  tracker.decOne(getHash(0b0100, state))
  ...
  tracker.decTwo(getHash(0b1100, state))
  tracker.decTwo(getHash(0b0110, state))
  ...
  tracker.decThree(getHash(0b1110, state))
  ...
}


2) There is not a lot of early elimination.
When a piece is placed, and the free pieces has exacly 2 free edges of any
given type and the board does not have this edge as a need, the 2 free pieces
must be connected.  

2022-06-01 *********************************************************************************

The base for #1 has been build. Gave a factor 2, but with at least one obvious optimization:
Delayed calculation of rotation.

<later>

Delayed rotation calculation implemented for WalkerE and (more importantly) a debug-oriented
sanity check of registered pieces was removed. Speed is now ~100K attempts/sec on a laptop.

2022-06-02 *********************************************************************************

When running testBacktrackReturnSolver_A it quickly reaches a state with multiple fields
having 0 possibl3 pieces: Instead an early termination should be done when updating the
state of surrounding fields when placing a piece.

The test checkPossible has been implemented and fires after some time when placed at the
end of placePiece. Cause currently unknown. Maybe it is due to the opposing counter?

3) It should not be possible to encounter a state with 0 possible. Fix it.
Unit test: Place selected pieces and check.
Sanity: Check that PieceTracker and Edge tracker are aligned

4) When multiple fields with the same number of pieces are availabe as possibles, choose
pseudo-randomly (Random with known seed) between them.

2022-06-06 *********************************************************************************

Go quad:

single = 1x1
quad = 2x2
hex = 4x4

5a) Pre-calculate all corners, edges, clues and inner quads (2x2)
Done with StatsTest. Preliminary (a bit too high) numbers:
 * Corners: 1301
 * Edge:   62807
 * All:   815652
 * Clue 1:  4112
 * Clue 2:  4108
 * Clue 3:  3599
 * Clue 4:  4347
 * Clue c:  3808

5b) Shift to quad-based setup
All base operations forward is on a 8x8 board with the pieces from 5a

6a) Calculate all possible hex (4x4) corners (involves clue pieces)
Guess: 1M valids/corner
Real: 32M

6b) Calculate all possible hex edges
Guess: 64M valids

7a) Calculate all possible hex corners at the same time
Might have far too many permutations, might have very few
Does not need placement on the board as it is a matter of eliminating
hex pieces that contain any quad pieces from a previous corner.
Use bitmaps of involved singles and make bitwise compare?

7b) (alternative to 7a) Build out from the hex corner and hit center clue
One 8x8 corner involved the center clue, so building that might be
combinatorally possible

2022-06-10 *********************************************************************************

8) From #6 + #7a: Valid 4*hex corners
With 32M unique hexes for each corner, the probably number of 4*hex corners are
32M * ((1024/(4*16))/1024)^16 * ((1024/(4*32))/1024)^16 * ((1024/(4*48))/1024)^16 ~= 48K

By extracting all states for each 32M hex corner (16*long_bytes = 128 bytes / hex),
then extracting all piece-IDs (8 bytes/piece-ID) and sorting those, it should be fairly
fast to isolate the ~48K valid combinations of 4 hex corners.

9) Related to #7b: Calculate all edge quads

2022-06-11 *********************************************************************************

Damn. The calculation in #8 is wrong as it only gives the number of valid hexes for the
LAST corner. This needs to be multiplied with the valids from all the previous corners.

2022-06-12 *********************************************************************************

10a) When working with quads, in the PieceTracker, keep track of which SINGLES has been used
(in a bitmap?). When considering if a quad has already been used, only look at the singles.
Conversely: Never remove quads from the tracker, only filter the quads in getters using
the singles bitmap.

10b) Can something similar be done with the edge tracker?

2022-06-14 *********************************************************************************

Use fastutils: https://twitter.com/tagir_valeev/status/1536317236276867073